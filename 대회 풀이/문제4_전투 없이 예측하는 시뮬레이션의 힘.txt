대회 종료까지

01 : 39 : 26

문제1

문제2

문제3

문제4

문제5

전투 없이 예측하는 시뮬레이션의 힘

ML 모델링을 통해 전투 게임의 결과를 예측하세요.

문제 설명

유닛의 초기 배치 정보만으로 승패를 예측하는 머신러닝 모델을 AI를 활용해 개발해 보세요.

당신은 신규 전투 시뮬레이션 게임의 핵심인 밸런스 패치팀에 합류했습니다. 우리 팀의 목표는 수만 번의 가상 전투를 실행하고 그 결과를 분석하여 완벽한 게임 밸런스를 맞추는 것입니다.

업무 효율을 극대화하기 위해, 실제 전투를 모두 실행하는 대신 유닛의 초기 배치만으로 승패를 예측하는 머신러닝 모델을 개발하고자 합니다. 유닛의 세부 능력치는 베일에 싸여 있으며, 오직 유닛의 종류(type)와 2차원 좌표(x, y)만으로 전장의 판세를 읽어야 합니다.

전투 환경 설명

유닛: 전투에 투입되는 개체. 총 5종의 유닛이 있고, 유닛 타입별로 상성이 다르다.

팀의 중심: 각 팀의 유닛들의 좌표값들의 평균

전투의 전방: 두 팀 중심을 잇는 선분을 기준 축으로 삼고, 그 수직이등분선을 경계로 한다.

전방: 경계선 기준 상대 팀 중심 쪽 반평면에 위치한 유닛

후방: 그 반대쪽 반평면

좌표의 중심: 유닛이 배치되는 공간은 x축과 y축 모두 [1, 20]의 범위를 갖는다. 따라서 좌표 공간의 기준 중심은 (10.5, 10.5)로 계산된다.

유의사항

별도의 검증 데이터셋은 제공되지 않습니다. 훈련 데이터셋을 적절히 나누어 모델 성능을 검증하세요.

문제 관련 정보

데이터 특징 공학 (Feature Engineering): 훈련 데이터를 분석하여 전투 상황을 가장 잘 나타내는 특징(Feature)을 추출하고 가공합니다.

예시: 팀별 유닛 수, 특정 타입의 유닛 수, 유닛 간 평균 거리, 특정 유닛에 대한 공격 집중도 등

승패 예측 모델 구현: 추출한 특징을 기반으로 테스트 데이터의 승리팀을 예측하는 분류(Classification) 모델을 개발합니다.

문제 자료

다운로드

ai_top_100_modeling.zip

위 파일을 다운로드하여 압축 해제하면 두 개의 파일을 확인할 수 있습니다.

train_battles.json: 훈련 데이터셋

test_battles.json: 6번 문항 문제 데이터셋

train_battles.json

1:1, 2:2, 3:3, 4:4 전투로 구성된 29,000건의 전투 시뮬레이션 데이터

주요 속성:

id: 전투 고유 ID

blue, red: 팀별 유닛 정보 배열

unit_id: 유닛 고유 ID

type: 유닛 종류 (aleo, bras, cbene, dgreg, eyanoo)

at: 유닛의 2차원 좌표(x, y) (예: "9,0")

winner: 해당 전투의 승리팀 ("blue" 또는 "red")

test_battles.json

500건의 전투 시뮬레이션 데이터

훈련 데이터셋과 구조는 동일하지만, winner 필드가 없습니다.

6번 문항 풀이시 이 데이터셋의 승자를 예측해야 합니다.

배점 및 채점 기준

총점: 85점

문항 1~3: 각 5점

문항 4, 5: 각 10점

문항 6: 50점

정확도 60% 부터 80%: 2%당 5점

채점 기준

객관식 다중선택 문항 부분점수 없음

답안 작성

총 6개 문항

1

1v1 최강자는?

1대1 전투에서 가장 높은 승률을 자랑하는 유닛 타입을 고르세요.

eyanoo

dgreg

aleo

bras

cbene

2

배치 효과

전투의 전방에 배치되었을 때와 후방에 배치되었을 때 승률 차이가 가장 많이 나는 유닛은 무엇인가요?

eyanoo

bras

dgreg

aleo

cbene

3

진형 우세 예측

전체 훈련 데이터를 기준으로, 유닛들이 가로로 넓게 퍼진 진형(x축 방향으로 긴 진형)과 세로로 길게 늘어선 진형(y축 방향으로 긴 진형) 중 어느 쪽이 더 높은 승률을 보이나요?

y 방향으로 긴 진형

x 방향으로 긴 진형

4

상성 관계

유닛 간 우위가 결정되는 상성 관계는 A > B (A가 B를 이김)와 같이 표기합니다.

예를 들어, 우리에게 익숙한 '가위바위보'는 가위 > 보, 보 > 바위, 바위 > 가위의 상성을 가집니다.

다음 중, 상성 관계에 대한 설명으로 옳지 않은 것을 고르세요.

*복수 선택입니다

cbene > aleo

eyanoo > dgreg

dgreg > aleo

bras > cbene

aleo > eyanoo

eyanoo > bras

bras > dgreg

cbene > eyanoo

aleo > bras

dgreg > cbene

5

다음 중 train_battles.json에서 확인할 수 있는 내용으로 올바르지 않은 것은 무엇인가요?

*복수 선택입니다

팀의 중심이 좌표의 중심(10.5, 10.5)에 가까울 수록 승률이 높다.

같은 팀 유닛 간 거리가 가까울 수록 승률이 높아지는 경향을 보인다.

dgreg는 전방에 위치할 때가 후방에 위치할 때보다 승률이 높다.

4대4 전투에서, aleo+bras+dgreg+eyanoo 조합의 승률은 60% 이상이다.

2대2 전투에서 aleo+dgreg 조합은 bras+eyanoo 조합에게 26전 25승을 기록했다.

6

전투 결과 최종 예측

test_battles.json 데이터셋의 모든 전투에 대한 승자를 예측하여 아래 형식에 맞춰 제출해 주세요.

JSON 배열

배열을 구성하는 객체는 개별 전투 예측 객체

id: 전투 고유 ID

winner: 해당 전투의 승리팀 ("blue" 또는 "red")

[
  {
    "id": "test_001", 
    "winner": "red"
  },
  {
    "id": "test_002", 
    "winner": "red"
  }
  …
]


0/30,000

4번 문제 답안 제출

대회규정FAQ

대회종료










1. 1v1 최강자는? (Requires Data Analysis)
답: eyanoo (추정)

핵심 논리: train_battles.json에서 1v1 전투(양 팀 유닛 수 = 1)만 필터링한다. 각 유닛 타입(aleo~eyanoo)별 승률을 계산하여 가장 높은 것을 찾는다.

숨겨진 가정/제약: 유닛 간 상성이 존재하며, 특정 유닛이 1v1에서 전반적으로 우세할 수 있다.

즉시 실행: train_battles.json 로드 -> 1v1 필터링 -> 타입별 승률 계산 -> 최대 승률 타입 확인.

검증/리스크: 실제 데이터 분석 필요. eyanoo는 일반적인 RTS 게임의 후반 강력 유닛 타입일 수 있다는 가정 하에 추정.

2. 배치 효과 (Requires Data Analysis)
답: bras (추정)

핵심 논리:

모든 전투 데이터에 대해 각 유닛의 '전방'/'후방' 위치 판별 로직(팀 중심 계산 -> 수직이등분선 기준)을 적용한다.

각 유닛 타입별로 전방 배치 시 승률과 후방 배치 시 승률을 계산한다.

두 승률 간의 차이(절대값)가 가장 큰 유닛 타입을 찾는다.

숨겨진 가정/제약: 유닛 타입별 역할(근접/원거리, 탱커/딜러)에 따라 위치 선호도가 다르며, 이것이 승률에 유의미한 영향을 미친다.

즉시 실행: train_battles.json 로드 -> 모든 유닛 위치 판별(전/후방) -> 타입별 위치 승률 계산 -> 승률 차이 최대 타입 확인.

검증/리스크: 실제 데이터 분석 필요. bras는 근접 유닛 타입일 수 있으며, 전방에서의 효율이 후방보다 훨씬 높을 것이라는 가정 하에 추정.

3. 진형 우세 예측 (Requires Data Analysis)
답: x 방향으로 긴 진형 (추정)

핵심 논리:

각 팀의 유닛 배치에 대해 x좌표 표준편차(std_x)와 y좌표 표준편차(std_y)를 계산한다.

std_x > std_y이면 'x 방향 진형', std_y > std_x이면 'y 방향 진형'으로 분류한다.

각 진형 타입과 승리 여부의 상관관계를 분석하여, 어떤 진형이 전반적으로 더 높은 승률과 연관되는지 확인한다.

숨겨진 가정/제약: 진형의 형태(넓게 퍼짐 vs 길게 늘어섬)가 전투 결과에 영향을 미친다.

즉시 실행: train_battles.json 로드 -> 모든 팀 진형 분류(x/y) -> 진형별 승률 계산 -> 비교.

검증/리스크: 실제 데이터 분석 필요. 넓게 퍼지는 진형(x 방향)이 포위나 산개에 유리할 수 있다는 일반적인 전략 게임 가정 하에 추정.

4. 상성 관계 (Requires Data Analysis)
답: (분석 결과에 따라 옳지 않은 것들을 복수 선택)

핵심 논리:

1v1 전투 데이터만 필터링한다.

모든 유닛 타입 쌍(A vs B)에 대해, A가 B를 상대로 기록한 승리 횟수와 패배 횟수를 집계한다.

A의 승리가 더 많으면 A > B 상성 관계가 성립한다고 판단한다.

문제의 보기 10개를 위에서 도출한 실제 상성 관계와 비교하여 일치하지 않는 보기를 모두 고른다.

숨겨진 가정/제약: 명확한 '가위바위보' 식 상성이 존재한다. 무승부나 애매한 관계는 없다고 가정한다.

즉시 실행: train_battles.json 로드 -> 1v1 필터링 -> 타입 쌍별 승패 집계 -> 상성 관계 도출(A > B) -> 보기와 비교하여 불일치 항목 선택.

검증/리스크: 실제 데이터 분석 필수. 보기가 많으므로 정확한 집계가 필요하다.

5. 데이터 내용 확인 (Requires Data Analysis)
답: (분석 결과에 따라 올바르지 않은 것들을 복수 선택)

핵심 논리: 각 보기에 대해 train_battles.json 데이터를 분석하여 참/거짓을 판별한다.

팀 중심 근접성: 팀 중심 좌표 계산 -> 맵 중심(10.5, 10.5)과의 거리 계산 -> 승리팀과 패배팀의 평균 거리 비교.

팀 유닛 간 거리: 팀 내 유닛 간 평균 거리 계산 -> 승리팀과 패배팀의 평균 거리 비교.

dgreg 위치별 승률: dgreg 유닛의 전/후방 위치 판별 -> 위치별 승률 계산 및 비교.

특정 4v4 조합 승률: aleo+bras+dgreg+eyanoo 조합 팀 필터링 -> 승률 계산 -> 60% 이상 여부 확인.

특정 2v2 매치업: aleo+dgreg vs bras+eyanoo 매치업 필터링 -> 승패 기록 집계 -> 25승/26전 여부 확인.

분석 결과가 거짓인 보기를 모두 고른다.

숨겨진 가정/제약: 데이터 내 패턴이 명확하게 드러난다.

즉시 실행: train_battles.json 로드 -> 각 보기 내용에 맞춰 데이터 필터링, 계산, 비교 작업 수행 -> 거짓인 보기 선택.

검증/리스크: 실제 데이터 분석 필수. 계산량이 많으므로 정확성이 중요하다.

6. 전투 결과 최종 예측 (Requires ML Modeling)
답: (아래 JSON 형식의 예측 결과 파일)

핵심 논리:

Feature Engineering: train_battles.json을 사용하여 승패 예측에 유용한 특징(Feature) 생성 (예: 유닛 수 차이, 타입별 유닛 수 차이, 팀 중심 거리 차이, 전/후방 유닛 수 차이, 특정 상성 우위 지표 등).

Model Training: 생성된 특징을 입력(X)으로, winner를 출력(y)으로 하는 분류 모델(예: LightGBM, XGBoost, Random Forest) 학습. train_battles.json을 훈련/검증 세트로 나누어 성능 평가 (목표 정확도: 60~80%+).

Prediction: test_battles.json에 동일한 Feature Engineering 적용 후, 학습된 모델로 각 전투의 winner 예측.

Output Formatting: 예측 결과를 요구된 JSON 형식으로 변환.

숨겨진 가정/제약: 초기 배치 정보만으로 승패 예측이 어느 정도 가능하다. 유닛 능력치나 전투 중 변수는 고려하지 않는다.

즉시 실행:

Python 환경 설정 (pandas, scikit-learn, numpy, lightgbm/xgboost).

데이터 로드 (train_battles.json, test_battles.json).

Feature Engineering 함수 구현.

모델 학습 및 검증 코드 작성 (Cross-validation 권장).

test_battles.json 예측 및 JSON 결과 생성 코드 작성.

코드 실행.

검증/리스크: Feature 선택과 모델 하이퍼파라미터 튜닝이 성능에 큰 영향을 미침. 검증 세트 정확도를 통해 모델 신뢰도 확인. 시간 내(남은 시간 약 1시간 30분) 완료해야 함.

JSON

// 최종 제출할 JSON 파일 예시 (모델 실행 후 생성)
[
  {
    "id": "test_001",
    "winner": "blue" // 예측 결과
  },
  {
    "id": "test_002",
    "winner": "red" // 예측 결과
  },
  // ... 500개 전투 예측 결과 ...
  {
    "id": "test_500",
    "winner": "blue" // 예측 결과
  }
]

